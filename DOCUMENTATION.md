# ğŸ¯ Real-Time Session System Documentation

## Overview

A production-ready session system with:
- âœ… **6-digit join codes** (generated by backend)
- âœ… **Cookie-based participant tracking** (survives page refresh)
- âœ… **Duplicate vote prevention** (database constraint)
- âœ… **Session expiration** (automatic cleanup)
- âœ… **Real-time sync** (Socket.IO)

---

## ğŸ”„ Complete Flow Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRESENTER  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 1. POST /api/sessions
       â”‚    { title, presenterId }
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   BACKEND        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Generate   â”‚  â”‚â”€â”€â–º Returns: { sessionId, joinCode: "A3B7K9", expiresAt }
â”‚  â”‚ Join Code  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Save to DB â”‚  â”‚â”€â”€â–º sessions table
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 2. Share join code "A3B7K9"
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PARTICIPANT â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 3. GET /api/join/A3B7K9
       â”‚    (withCredentials: true)
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   BACKEND                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Validate join code â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Generate cookie ID â”‚  â”‚â”€â”€â–º participant_12345...
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Set cookie header  â”‚  â”‚â”€â”€â–º Set-Cookie: participant_id=...
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ Returns: { sessionId, sessionTitle, participantCookie }
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PARTICIPANT â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 4. Connect to Socket.IO
       â”‚    (cookie automatically sent)
       â”‚
       â”‚ 5. emit('join_session', {
       â”‚      joinCode: "A3B7K9",
       â”‚      participantCookie: "participant_12345...",
       â”‚      nickname: "Alice"
       â”‚    })
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   BACKEND SOCKET HANDLER         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Check if participant      â”‚   â”‚
â”‚  â”‚ already exists (cookie)   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚           â”‚                       â”‚
â”‚           â”œâ”€ NEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Create participant record
â”‚           â”‚                       â”‚ participants table
â”‚           â”‚                       â”‚
â”‚           â””â”€ EXISTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Update socket_id
â”‚                                   â”‚ is_connected = true
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ emit('session_joined', {
       â”‚   sessionId, sessionTitle,
       â”‚   participantId, activeQuestion,
       â”‚   participantCount
       â”‚ })
       â”‚
       â”‚ broadcast('participant_joined', {
       â”‚   participantId, nickname, participantCount
       â”‚ })
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PARTICIPANT â”‚â”€â”€â–º Sees: "Waiting for question..."
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    Shows: "5 participants online"


       [PRESENTER ACTIVATES QUESTION]


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ PARTICIPANT â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ â—„â”€â”€ on('question_activated', {
       â”‚       question: { id, text, type, options },
       â”‚       voteCount: 0
       â”‚     })
       â”‚
       â”‚ User selects answer
       â”‚
       â”‚ 6. emit('submit_vote', {
       â”‚      questionId: "q123",
       â”‚      voteData: { answer: "Option A" }
       â”‚    })
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   BACKEND SOCKET HANDLER         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ INSERT INTO votes         â”‚   â”‚
â”‚  â”‚ (question_id,             â”‚   â”‚
â”‚  â”‚  participant_id,          â”‚   â”‚
â”‚  â”‚  session_id, vote_data)   â”‚   â”‚
â”‚  â”‚ UNIQUE(question_id,       â”‚   â”‚
â”‚  â”‚        participant_id)    â”‚   â”‚â”€â”€â”
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
       â”‚                               â”‚
       â”œâ”€ SUCCESS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Vote saved
       â”‚                               â”‚
       â”‚   emit('vote_submitted', {    â”‚
       â”‚     success: true,             â”‚
       â”‚     questionId                 â”‚
       â”‚   })                           â”‚
       â”‚                               â”‚
       â”‚   broadcast('vote_count_updated', {
       â”‚     questionId,                â”‚
       â”‚     voteCount: 5               â”‚
       â”‚   })                           â”‚
       â”‚                               â”‚
       â””â”€ DUPLICATE (23505) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Constraint violation
                                       â”‚
           emit('error', {             â”‚
             code: 'DUPLICATE_VOTE',   â”‚
             message: 'Already voted'  â”‚
           })                          â”‚


       [SESSION EXPIRATION - AUTOMATIC]


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SESSION EXPIRATION MANAGER  â”‚
â”‚  (runs every 5 minutes)      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ SELECT * FROM sessionsâ”‚   â”‚
â”‚  â”‚ WHERE status='active' â”‚   â”‚
â”‚  â”‚ AND expires_at < NOW()â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ UPDATE sessions       â”‚   â”‚â”€â”€â–º Sets status='ended'
â”‚  â”‚ SET status='ended'    â”‚   â”‚    Sets ended_at=NOW()
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“Š Database Schema Explained

### Sessions Table
```sql
CREATE TABLE sessions (
    id UUID PRIMARY KEY,
    join_code VARCHAR(6) UNIQUE NOT NULL,  -- "A3B7K9"
    title VARCHAR(255) NOT NULL,
    presenter_id VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'active',   -- 'active' or 'ended'
    expires_at TIMESTAMP NOT NULL,         -- Auto-expiration time
    ended_at TIMESTAMP                     -- When manually/auto ended
);
```

**Key Points:**
- `join_code` is UNIQUE - prevents collisions
- `expires_at` - used for automatic expiration
- `ended_at` - tracks when session actually ended

### Participants Table
```sql
CREATE TABLE participants (
    id UUID PRIMARY KEY,
    session_id UUID REFERENCES sessions(id),
    participant_cookie VARCHAR(100) NOT NULL,  -- From cookie
    socket_id VARCHAR(100),                    -- Current connection
    nickname VARCHAR(100),
    is_connected BOOLEAN DEFAULT true,
    joined_at TIMESTAMP,
    last_seen_at TIMESTAMP,
    UNIQUE(session_id, participant_cookie)     -- Prevents duplicates
);
```

**Key Points:**
- `participant_cookie` - persistent identifier across reconnections
- `socket_id` - current WebSocket connection (changes on reconnect)
- `UNIQUE(session_id, participant_cookie)` - one participant per session
- `is_connected` - tracks live status

### Votes Table
```sql
CREATE TABLE votes (
    id UUID PRIMARY KEY,
    question_id UUID REFERENCES questions(id),
    participant_id UUID REFERENCES participants(id),
    session_id UUID REFERENCES sessions(id),
    vote_data JSONB NOT NULL,
    voted_at TIMESTAMP,
    UNIQUE(question_id, participant_id)  -- ğŸ”’ DUPLICATE PREVENTION
);
```

**Key Points:**
- `UNIQUE(question_id, participant_id)` - **prevents duplicate votes**
- Database enforces this, not application logic
- Returns error code `23505` on duplicate attempt

---

## ğŸ”‘ Key Features Explained

### 1. Join Code Generation

```typescript
// backend/src/utils/helpers.ts
import { customAlphabet } from 'nanoid';

// Excludes ambiguous characters: 0, O, I, 1, L
const generateCode = customAlphabet('23456789ABCDEFGHJKLMNPQRSTUVWXYZ', 6);

export const generateJoinCode = (): string => {
  return generateCode(); // e.g., "A3B7K9"
};
```

**Features:**
- 6 characters long
- Uppercase letters + numbers only
- Excludes confusing characters (0/O, 1/I/L)
- ~1 billion possible codes (36^6)
- Retry logic handles collisions

### 2. Cookie-Based Participant Tracking

```typescript
// backend/src/app.ts
app.get('/api/join/:joinCode', async (req, res) => {
  // Get existing cookie or generate new one
  const existingCookie = req.cookies[PARTICIPANT_COOKIE_NAME];
  const participantCookie = getOrCreateParticipantCookie(existingCookie);

  // Set cookie in response
  res.cookie(PARTICIPANT_COOKIE_NAME, participantCookie, {
    httpOnly: false,    // Frontend needs to read it
    secure: true,       // HTTPS only in production
    sameSite: 'lax',    // CSRF protection
    maxAge: 30 * 24 * 60 * 60 * 1000  // 30 days
  });

  res.json({ participantCookie });
});
```

**Benefits:**
- Survives page refresh
- Works across tabs
- No login required
- Prevents duplicate participants

### 3. Duplicate Vote Prevention

**Two-Layer Protection:**

**Layer 1: Database Constraint**
```sql
UNIQUE(question_id, participant_id)
```
- Enforced at database level
- Cannot be bypassed
- Returns error code `23505`

**Layer 2: Application Check**
```typescript
// backend/src/services/database.ts
async submitVote(questionId, participantId, sessionId, voteData) {
  try {
    await pool.query(
      `INSERT INTO votes (question_id, participant_id, session_id, vote_data)
       VALUES ($1, $2, $3, $4)`,
      [questionId, participantId, sessionId, JSON.stringify(voteData)]
    );
    return { success: true, isDuplicate: false };
  } catch (error) {
    if (error.code === '23505') {  // Unique constraint violation
      return { success: false, isDuplicate: true };
    }
    throw error;
  }
}
```

**Frontend Handling:**
```typescript
socket.on('error', (data) => {
  if (data.code === 'DUPLICATE_VOTE') {
    setHasVoted(true);
    showMessage('You have already voted on this question');
  }
});
```

### 4. Session Expiration Logic

**Automatic Expiration:**
```typescript
// backend/src/server.ts
class SessionExpirationManager {
  constructor(checkIntervalMinutes = 5) {
    this.intervalMs = checkIntervalMinutes * 60 * 1000;
  }

  start() {
    // Run immediately
    this.checkExpiredSessions();
    
    // Then periodically
    setInterval(() => {
      this.checkExpiredSessions();
    }, this.intervalMs);
  }

  async checkExpiredSessions() {
    // Use database function
    const result = await db.query('SELECT expire_old_sessions()');
    console.log(`Expired ${result} sessions`);
  }
}
```

**Database Function:**
```sql
CREATE OR REPLACE FUNCTION expire_old_sessions()
RETURNS INTEGER AS $$
DECLARE
  expired_count INTEGER;
BEGIN
  UPDATE sessions 
  SET status = 'ended', ended_at = CURRENT_TIMESTAMP
  WHERE status = 'active' 
  AND expires_at < CURRENT_TIMESTAMP;
  
  GET DIAGNOSTICS expired_count = ROW_COUNT;
  RETURN expired_count;
END;
$$ LANGUAGE plpgsql;
```

**Manual Expiration:**
```typescript
// Set expiration on creation
const expiresAt = new Date();
expiresAt.setHours(expiresAt.getHours() + 24); // 24 hours

await pool.query(
  `INSERT INTO sessions (join_code, title, presenter_id, expires_at)
   VALUES ($1, $2, $3, $4)`,
  [joinCode, title, presenterId, expiresAt]
);
```

---

## ğŸ¯ Socket Events Reference

### Client â†’ Server

| Event | Payload | Description |
|-------|---------|-------------|
| `join_session` | `{ joinCode, participantCookie, nickname? }` | Join a session |
| `submit_vote` | `{ questionId, voteData }` | Submit a vote |
| `activate_question` | `{ questionId }` | Activate question (presenter) |
| `show_results` | `{ questionId }` | Show results (presenter) |
| `end_session` | - | End session (presenter) |

### Server â†’ Client

| Event | Payload | Description |
|-------|---------|-------------|
| `session_joined` | `{ sessionId, sessionTitle, participantId, activeQuestion, participantCount }` | Confirmation of join |
| `question_activated` | `{ question, voteCount }` | New question started |
| `vote_submitted` | `{ success, questionId }` | Vote confirmation |
| `vote_count_updated` | `{ questionId, voteCount }` | Live vote count |
| `results_shown` | `{ questionId, results }` | Results revealed |
| `participant_joined` | `{ participantId, nickname, participantCount }` | Someone joined |
| `participant_left` | `{ participantId, participantCount }` | Someone left |
| `session_ended` | - | Session ended |
| `error` | `{ code, message, details? }` | Error occurred |

---

## ğŸš€ Usage Examples

### Example 1: Create Session (Presenter)

```typescript
const response = await axios.post('http://localhost:3001/api/sessions', {
  title: 'Product Feedback Session',
  presenterId: 'presenter@example.com'
});

console.log(response.data);
// {
//   sessionId: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
//   joinCode: "A3B7K9",
//   expiresAt: "2024-02-09T15:30:00Z",
//   title: "Product Feedback Session"
// }
```

### Example 2: Join Session (Participant)

```typescript
// Step 1: Call join endpoint (sets cookie)
const response = await axios.get(
  'http://localhost:3001/api/join/A3B7K9',
  { withCredentials: true }  // Important!
);

const { participantCookie } = response.data;

// Step 2: Connect to WebSocket
const socket = io('http://localhost:3001', {
  withCredentials: true  // Sends cookie
});

// Step 3: Join session
socket.emit('join_session', {
  joinCode: 'A3B7K9',
  participantCookie: participantCookie,
  nickname: 'Alice'
});
```

### Example 3: Submit Vote

```typescript
// Listen for vote confirmation
socket.on('vote_submitted', (data) => {
  console.log('Vote confirmed:', data);
  setHasVoted(true);
});

// Listen for duplicate error
socket.on('error', (error) => {
  if (error.code === 'DUPLICATE_VOTE') {
    alert('You already voted!');
    setHasVoted(true);
  }
});

// Submit vote
socket.emit('submit_vote', {
  questionId: 'q123',
  voteData: { selectedOption: 0, comment: 'Great product!' }
});
```

### Example 4: Check Expiration

```typescript
// Get session info
const session = await axios.get('http://localhost:3001/api/sessions/A3B7K9');

const expiresAt = new Date(session.data.session.expires_at);
const now = new Date();

if (now > expiresAt) {
  console.log('Session has expired');
  // Backend will auto-expire it on next check
}
```

---

## ğŸ”’ Security Features

### 1. Input Validation
```typescript
export const isValidJoinCode = (code: string): boolean => {
  return /^[23456789ABCDEFGHJKLMNPQRSTUVWXYZ]{6}$/.test(code);
};

export const sanitizeInput = (input: string, maxLength = 255): string => {
  return input
    .trim()
    .replace(/[<>]/g, '')  // Remove HTML tags
    .substring(0, maxLength);
};
```

### 2. Database Constraints
- Foreign keys enforce referential integrity
- Unique constraints prevent duplicates
- Check constraints validate data
- Parameterized queries prevent SQL injection

### 3. Cookie Security
```typescript
const COOKIE_OPTIONS = {
  httpOnly: false,     // Frontend needs access
  secure: true,        // HTTPS only in production
  sameSite: 'lax',     // CSRF protection
  maxAge: 30 days,     // Expiration
  path: '/'            // Available site-wide
};
```

---

## ğŸ“ˆ Performance Considerations

### Database Indexes
```sql
CREATE INDEX idx_sessions_join_code ON sessions(join_code);
CREATE INDEX idx_participants_socket ON participants(socket_id);
CREATE INDEX idx_votes_question ON votes(question_id);
```

### Connection Pooling
```typescript
const pool = new Pool({
  max: 10,                    // Max connections
  idleTimeoutMillis: 30000,   // Release after 30s idle
});
```

### Periodic Cleanup
```typescript
// Run every 5 minutes
setInterval(async () => {
  await sessionService.cleanupExpiredSessions();
}, 5 * 60 * 1000);
```

---

## ğŸ§ª Testing Examples

### Test Duplicate Vote Prevention
```bash
# Terminal 1: Submit first vote
curl -X POST http://localhost:3001/api/votes \
  -H "Content-Type: application/json" \
  -d '{"questionId":"q1","participantId":"p1","voteData":{"answer":"A"}}'

# Response: { "success": true }

# Terminal 2: Try to vote again (same participant + question)
curl -X POST http://localhost:3001/api/votes \
  -H "Content-Type: application/json" \
  -d '{"questionId":"q1","participantId":"p1","voteData":{"answer":"B"}}'

# Response: { "success": false, "isDuplicate": true }
```

### Test Session Expiration
```sql
-- Create session that expires in 1 minute
INSERT INTO sessions (join_code, title, presenter_id, expires_at)
VALUES ('TEST01', 'Test Session', 'test', NOW() + INTERVAL '1 minute');

-- Wait 2 minutes...

-- Run expiration check
SELECT expire_old_sessions();
-- Returns: 1 (one session expired)

-- Verify status changed
SELECT status FROM sessions WHERE join_code = 'TEST01';
-- Returns: 'ended'
```

---

## ğŸ“ Environment Variables

```env
# Server
PORT=3001
NODE_ENV=production
CORS_ORIGIN=http://localhost:3000

# Database
DB_HOST=localhost
DB_PORT=5432
DB_NAME=session_system
DB_USER=postgres
DB_PASSWORD=your_password

# Session Settings
SESSION_EXPIRATION_HOURS=24
CLEANUP_INTERVAL_MINUTES=5
```

---

## ğŸ“ Complete Setup Guide

```bash
# 1. Setup database
createdb session_system
psql -d session_system -f database/schema.sql

# 2. Install backend dependencies
cd backend
npm install

# 3. Configure environment
cp .env.example .env
# Edit .env with your database credentials

# 4. Start backend
npm run dev
# Server running on http://localhost:3001

# 5. Install frontend dependencies
cd frontend
npm install

# 6. Start frontend
npm run dev
# Frontend running on http://localhost:3000
```

---

## âœ… Production Checklist

- [ ] Use strong `DB_PASSWORD`
- [ ] Set `NODE_ENV=production`
- [ ] Enable `secure: true` for cookies (HTTPS)
- [ ] Configure proper `CORS_ORIGIN`
- [ ] Setup database backups
- [ ] Monitor session expiration logs
- [ ] Implement rate limiting
- [ ] Add presenter authentication
- [ ] Setup logging service
- [ ] Configure SSL certificates

---

**System is production-ready with all key features implemented!** ğŸš€
